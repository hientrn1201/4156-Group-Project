<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DocumentService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Knowledge Management Service</a> &gt; <a href="index.source.html" class="el_package">dev.coms4156.project.service</a> &gt; <span class="el_source">DocumentService.java</span></div><h1>DocumentService.java</h1><pre class="source lang-java linenums">package dev.coms4156.project.service;

import dev.coms4156.project.model.Document;
import dev.coms4156.project.model.DocumentChunk;
import dev.coms4156.project.repository.DocumentRepository;
import java.io.IOException;
import java.util.List;
import java.util.Optional;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

/**
 * Service responsible for managing document processing and CRUD operations.
 * &lt;p&gt;
 * The {@code DocumentService} handles the complete document lifecycle, including upload,
 * text extraction, chunking, embedding generation, and summarization. It integrates with
 * {@link DocumentTextExtractionService}, {@link DocumentChunkingService}, and
 * {@link SimpleEmbeddingService} to orchestrate end-to-end document processing.
 * &lt;/p&gt;
 */
@Service
public class DocumentService {

  private final DocumentRepository documentRepository;
  private final DocumentTextExtractionService textExtractionService;
  private final DocumentChunkingService chunkingService;
  private final SimpleEmbeddingService embeddingService;

  /**
   * Constructs a new {@code DocumentService} instance with all required dependencies.
   *
   * @param documentRepository    the {@link DocumentRepository} used for persisting and retrieving
   *                              documents.
   * @param textExtractionService the {@link DocumentTextExtractionService} used to extract raw
   *                              text from uploaded files.
   * @param chunkingService       the {@link DocumentChunkingService} responsible for dividing text
   *                              into manageable chunks.
   * @param embeddingService      the {@link SimpleEmbeddingService} responsible for generating
   *                              vector embeddings for each chunk.
   */
  public DocumentService(DocumentRepository documentRepository,
                         DocumentTextExtractionService textExtractionService,
                         DocumentChunkingService chunkingService,
<span class="fc" id="L45">                         SimpleEmbeddingService embeddingService) {</span>
<span class="fc" id="L46">    this.documentRepository = documentRepository;</span>
<span class="fc" id="L47">    this.textExtractionService = textExtractionService;</span>
<span class="fc" id="L48">    this.chunkingService = chunkingService;</span>
<span class="fc" id="L49">    this.embeddingService = embeddingService;</span>
<span class="fc" id="L50">  }</span>

  /**
   * Processes an uploaded document through the complete pipeline.
   *
   * @param file the uploaded {@link MultipartFile} to process.
   * @return the processed {@link Document} entity, including extracted text and summary.
   * @throws IOException              if reading the uploaded file fails.
   * @throws IllegalArgumentException if the file is empty or of an unsupported type.
   * @throws RuntimeException         if any pipeline step fails.
   */
  @Transactional
  public Document processDocument(MultipartFile file) throws IOException {
<span class="fc" id="L63">    System.out.println(&quot;Starting document processing for: &quot; + file.getOriginalFilename());</span>

    // Validate file
<span class="fc bfc" id="L66" title="All 2 branches covered.">    if (file.isEmpty()) {</span>
<span class="fc" id="L67">      throw new IllegalArgumentException(&quot;File is empty&quot;);</span>
    }

    // Check if file type is supported
<span class="fc" id="L71">    String contentType = textExtractionService.detectContentType(file);</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">    if (!textExtractionService.isSupportedContentType(contentType)) {</span>
<span class="fc" id="L73">      throw new IllegalArgumentException(&quot;Unsupported file type: &quot; + contentType);</span>
    }

    // Create document entity
<span class="fc" id="L77">    Document document = new Document();</span>
<span class="fc" id="L78">    document.setFilename(file.getOriginalFilename());</span>
<span class="fc" id="L79">    document.setFileSize(file.getSize());</span>
<span class="fc" id="L80">    document.setContentType(contentType);</span>
<span class="fc" id="L81">    document.setProcessingStatus(Document.ProcessingStatus.UPLOADED);</span>

    // Save document
<span class="fc" id="L84">    document = documentRepository.save(document);</span>

    try {
      // Step 1: Extract text using Apache Tika
<span class="fc" id="L88">      System.out.println(&quot;Step 1: Extracting text from document: &quot; + document.getId());</span>
<span class="fc" id="L89">      String extractedText = textExtractionService.extractText(file);</span>

<span class="pc bpc" id="L91" title="2 of 4 branches missed.">      if (extractedText == null || extractedText.trim().isEmpty()) {</span>
<span class="nc" id="L92">        throw new RuntimeException(&quot;No text could be extracted from the document&quot;);</span>
      }

<span class="fc" id="L95">      document.setExtractedText(extractedText);</span>
<span class="fc" id="L96">      document.setProcessingStatus(Document.ProcessingStatus.TEXT_EXTRACTED);</span>
<span class="fc" id="L97">      document = documentRepository.save(document);</span>

      // Step 2: Chunk the document (in memory only)
<span class="fc" id="L100">      System.out.println(&quot;Step 2: Chunking document: &quot; + document.getId());</span>
<span class="fc" id="L101">      List&lt;DocumentChunk&gt; chunks = chunkingService.chunkDocument(document);</span>

<span class="pc bpc" id="L103" title="1 of 2 branches missed.">      if (chunks.isEmpty()) {</span>
<span class="nc" id="L104">        throw new RuntimeException(&quot;No chunks could be created from the document&quot;);</span>
      }

      // Step 3: Generate embeddings for chunks
<span class="fc" id="L108">      System.out.println(&quot;Step 3: Generating embeddings for &quot; + chunks.size() + &quot; chunks&quot;);</span>
<span class="fc" id="L109">      embeddingService.generateEmbeddings(chunks);</span>

<span class="fc" id="L111">      document.setProcessingStatus(Document.ProcessingStatus.CHUNKED);</span>
<span class="fc" id="L112">      document = documentRepository.save(document);</span>

<span class="fc" id="L114">      document.setProcessingStatus(Document.ProcessingStatus.EMBEDDINGS_GENERATED);</span>
<span class="fc" id="L115">      document = documentRepository.save(document);</span>

      // Step 4: Generate summary (optional - can be implemented later)
<span class="fc" id="L118">      System.out.println(&quot;Step 4: Generating summary for document: &quot; + document.getId());</span>
<span class="fc" id="L119">      String summary = generateSummary(extractedText);</span>

<span class="fc" id="L121">      document.setSummary(summary);</span>
<span class="fc" id="L122">      document.setProcessingStatus(Document.ProcessingStatus.COMPLETED);</span>
<span class="fc" id="L123">      document = documentRepository.save(document);</span>

<span class="fc" id="L125">      System.out.println(&quot;Successfully processed document: &quot; + document.getFilename() + &quot; with &quot;</span>
<span class="fc" id="L126">          + chunks.size() + &quot; chunks&quot;);</span>
<span class="fc" id="L127">      return document;</span>

<span class="nc" id="L129">    } catch (Exception e) {</span>
<span class="nc" id="L130">      System.err.println(&quot;Error processing document &quot; + document.getId() + &quot;: &quot; + e.getMessage());</span>
<span class="nc" id="L131">      e.printStackTrace();</span>
<span class="nc" id="L132">      document.setProcessingStatus(Document.ProcessingStatus.FAILED);</span>
<span class="nc" id="L133">      documentRepository.save(document);</span>
<span class="nc" id="L134">      throw new RuntimeException(&quot;Document processing failed&quot;, e);</span>
    }
  }


  /**
   * Retrieves a document by its unique ID.
   *
   * @param id the document ID.
   * @return an {@link Optional} containing the document if found, or empty if not found.
   */
  public Optional&lt;Document&gt; getDocumentById(Long id) {
<span class="fc" id="L146">    return documentRepository.findById(id);</span>
  }

  /**
   * Retrieves all stored documents.
   *
   * @return a list of all {@link Document} entities.
   */
  public List&lt;Document&gt; getAllDocuments() {
<span class="fc" id="L155">    return documentRepository.findAll();</span>
  }

  /**
   * Retrieves all documents matching a given filename.
   *
   * @return a list of all matching {@link Document} entities.
   */
  public List&lt;Document&gt; getDocumentsByFilename(String filename) {
<span class="nc" id="L164">    return documentRepository.findByFilenameContaining(filename);</span>
  }

  /**
   * Retrieves all documents that match a specific processing status.
   *
   * @param status the {@link Document.ProcessingStatus} filter.
   * @return a list of documents with the specified status.
   */
  public List&lt;Document&gt; getDocumentsByStatus(Document.ProcessingStatus status) {
<span class="fc" id="L174">    return documentRepository.findByProcessingStatus(status);</span>
  }

  /**
   * Deletes a document and all associated data such as chunks and embeddings.
   *
   * @param id the ID of the document to delete.
   */
  @Transactional
  public void deleteDocument(Long id) {
<span class="fc" id="L184">    documentRepository.deleteById(id);</span>
<span class="fc" id="L185">    System.out.println(&quot;Deleted document: &quot; + id);</span>
<span class="fc" id="L186">  }</span>

  /**
   * Retrieves all {@link DocumentChunk} instances belonging to a given document.
   *
   * @param documentId the ID of the document.
   * @return a list of chunks for the specified document.
   * @throws IllegalArgumentException if the document does not exist.
   */
  public List&lt;DocumentChunk&gt; getDocumentChunks(Long documentId) {
<span class="fc" id="L196">    return chunkingService.getChunksForDocument(documentId);</span>
  }

  /**
   * Retrieves statistical information about the chunking of a document,
   * including the number of chunks, average chunk length, and overlap ratio.
   *
   * @param documentId the ID of the document to analyze.
   * @return a {@link DocumentChunkingService.ChunkStatistics} object containing metrics.
   * @throws IllegalArgumentException if the document is not found.
   */
  public DocumentChunkingService.ChunkStatistics getChunkStatistics(Long documentId) {
<span class="fc" id="L208">    Optional&lt;Document&gt; document = getDocumentById(documentId);</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">    if (document.isEmpty()) {</span>
<span class="nc" id="L210">      throw new IllegalArgumentException(&quot;Document not found: &quot; + documentId);</span>
    }
<span class="fc" id="L212">    return chunkingService.getChunkStatistics(document.get());</span>
  }

  /**
   * Generates embeddings for all chunks of a given document that currently
   * lack embeddings in the database.
   *
   * @param documentId the ID of the document to process.
   * @return the number of chunks for which embeddings were generated.
   */
  @Transactional
  public int generateEmbeddingsForDocument(Long documentId) {
<span class="fc" id="L224">    return embeddingService.generateEmbeddingsForDocument(documentId);</span>
  }

  /**
   * Finds chunks that are semantically similar to a given query text.
   *
   * @param queryText the query string to match against.
   * @param limit     the maximum number of similar chunks to return.
   * @return a list of the most similar {@link DocumentChunk} entities.
   */
  public List&lt;DocumentChunk&gt; findSimilarChunks(String queryText, int limit) {
<span class="fc" id="L235">    return embeddingService.findSimilarChunks(queryText, limit);</span>
  }


  /**
   * Generates a simple summary of the documentâ€™s text content (placeholder for now).
   *
   * @param text the extracted text to summarize.
   * @return a short summary string, or a placeholder message if text is unavailable.
   */
  private String generateSummary(String text) {
<span class="pc bpc" id="L246" title="2 of 4 branches missed.">    if (text == null || text.trim().isEmpty()) {</span>
<span class="nc" id="L247">      return &quot;No summary available&quot;;</span>
    }

    // Simple truncation-based summary (first 200 characters)
<span class="fc" id="L251">    String cleanedText = text.replaceAll(&quot;\\s+&quot;, &quot; &quot;).trim();</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">    if (cleanedText.length() &lt;= 200) {</span>
<span class="fc" id="L253">      return cleanedText;</span>
    }

    // Try to break at sentence boundary
<span class="nc" id="L257">    String truncated = cleanedText.substring(0, 200);</span>
<span class="nc" id="L258">    int lastPeriod = truncated.lastIndexOf('.');</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">    if (lastPeriod &gt; 100) {</span>
<span class="nc" id="L260">      return truncated.substring(0, lastPeriod + 1);</span>
    }

<span class="nc" id="L263">    return truncated + &quot;...&quot;;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>