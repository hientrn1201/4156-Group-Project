<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DocumentService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Knowledge Management Service</a> &gt; <a href="index.source.html" class="el_package">dev.coms4156.project.service</a> &gt; <span class="el_source">DocumentService.java</span></div><h1>DocumentService.java</h1><pre class="source lang-java linenums">package dev.coms4156.project.service;

import dev.coms4156.project.model.Document;
import dev.coms4156.project.model.DocumentChunk;
import dev.coms4156.project.model.DocumentRelationship;
import dev.coms4156.project.repository.DocumentChunkRepository;
import dev.coms4156.project.repository.DocumentRelationshipRepository;
import dev.coms4156.project.repository.DocumentRepository;
import java.io.IOException;
import java.util.List;
import java.util.Optional;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

/**
 * Service responsible for managing document processing and CRUD operations.
 * &lt;p&gt;
 * The {@code DocumentService} handles the complete document lifecycle,
 * including upload,
 * text extraction, chunking, embedding generation, and summarization. It
 * integrates with
 * {@link DocumentTextExtractionService}, {@link DocumentChunkingService}, and
 * {@link SimpleEmbeddingService} to orchestrate end-to-end document processing.
 * &lt;/p&gt;
 */
@Service
public class DocumentService {

  private final DocumentRepository documentRepository;
  private final DocumentChunkRepository documentChunkRepository;
  private final DocumentRelationshipRepository documentRelationshipRepository;
  private final DocumentTextExtractionService textExtractionService;
  private final DocumentChunkingService chunkingService;
  private final SimpleEmbeddingService embeddingService;

  /**
   * Constructs a new {@code DocumentService} instance with all required
   * dependencies.
   *
   * @param documentRepository             the {@link DocumentRepository} used for
   *                                       persisting and retrieving
   *                                       documents.
   * @param documentChunkRepository        the {@link DocumentChunkRepository}
   *                                       used for managing chunks.
   * @param documentRelationshipRepository the
   *                                       {@link DocumentRelationshipRepository}
   *                                       used for managing relationships.
   * @param textExtractionService          the
   *                                       {@link DocumentTextExtractionService}
   *                                       used to extract raw
   *                                       text from uploaded files.
   * @param chunkingService                the {@link DocumentChunkingService}
   *                                       responsible for dividing text
   *                                       into manageable chunks.
   * @param embeddingService               the {@link SimpleEmbeddingService}
   *                                       responsible for generating
   *                                       vector embeddings for each chunk.
   */
  public DocumentService(DocumentRepository documentRepository,
      DocumentChunkRepository documentChunkRepository,
      DocumentRelationshipRepository documentRelationshipRepository,
      DocumentTextExtractionService textExtractionService,
      DocumentChunkingService chunkingService,
<span class="fc" id="L65">      SimpleEmbeddingService embeddingService) {</span>
<span class="fc" id="L66">    this.documentRepository = documentRepository;</span>
<span class="fc" id="L67">    this.documentChunkRepository = documentChunkRepository;</span>
<span class="fc" id="L68">    this.documentRelationshipRepository = documentRelationshipRepository;</span>
<span class="fc" id="L69">    this.textExtractionService = textExtractionService;</span>
<span class="fc" id="L70">    this.chunkingService = chunkingService;</span>
<span class="fc" id="L71">    this.embeddingService = embeddingService;</span>
<span class="fc" id="L72">  }</span>

  /**
   * Processes an uploaded document through the complete pipeline.
   */
  @Transactional
  public Document processDocument(MultipartFile file) throws IOException {
<span class="fc" id="L79">    System.out.println(&quot;Starting document processing for: &quot; + file.getOriginalFilename());</span>

    // Validate file
<span class="fc bfc" id="L82" title="All 2 branches covered.">    if (file.isEmpty()) {</span>
<span class="fc" id="L83">      throw new IllegalArgumentException(&quot;File is empty&quot;);</span>
    }

    // Check if file type is supported
<span class="fc" id="L87">    String contentType = textExtractionService.detectContentType(file);</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">    if (!textExtractionService.isSupportedContentType(contentType)) {</span>
<span class="fc" id="L89">      throw new IllegalArgumentException(&quot;Unsupported file type: &quot; + contentType);</span>
    }

    // Create document entity
<span class="fc" id="L93">    Document document = new Document();</span>
<span class="fc" id="L94">    document.setFilename(file.getOriginalFilename());</span>
<span class="fc" id="L95">    document.setFileSize(file.getSize());</span>
<span class="fc" id="L96">    document.setContentType(contentType);</span>
<span class="fc" id="L97">    document.setProcessingStatus(Document.ProcessingStatus.UPLOADED);</span>

    // Save document
<span class="fc" id="L100">    document = documentRepository.save(document);</span>

    try {
      // Step 1: Extract text using Apache Tika
<span class="fc" id="L104">      System.out.println(&quot;Step 1: Extracting text from document: &quot; + document.getId());</span>
<span class="fc" id="L105">      String extractedText = textExtractionService.extractText(file);</span>

<span class="fc bfc" id="L107" title="All 4 branches covered.">      if (extractedText == null || extractedText.trim().isEmpty()) {</span>
<span class="fc" id="L108">        throw new RuntimeException(&quot;No text could be extracted from the document&quot;);</span>
      }

<span class="fc" id="L111">      document.setExtractedText(extractedText);</span>
<span class="fc" id="L112">      document.setProcessingStatus(Document.ProcessingStatus.TEXT_EXTRACTED);</span>
<span class="fc" id="L113">      document = documentRepository.save(document);</span>

      // Step 2: Chunk the document (in memory only)
<span class="fc" id="L116">      System.out.println(&quot;Step 2: Chunking document: &quot; + document.getId());</span>
<span class="fc" id="L117">      List&lt;DocumentChunk&gt; chunks = chunkingService.chunkDocument(document);</span>

<span class="fc bfc" id="L119" title="All 2 branches covered.">      if (chunks.isEmpty()) {</span>
<span class="fc" id="L120">        throw new RuntimeException(&quot;No chunks could be created from the document&quot;);</span>
      }

      // Step 3: Generate embeddings for chunks
<span class="fc" id="L124">      System.out.println(&quot;Step 3: Generating embeddings for &quot; + chunks.size() + &quot; chunks&quot;);</span>
<span class="fc" id="L125">      embeddingService.generateEmbeddings(chunks);</span>

<span class="fc" id="L127">      document.setProcessingStatus(Document.ProcessingStatus.CHUNKED);</span>
<span class="fc" id="L128">      document = documentRepository.save(document);</span>

<span class="fc" id="L130">      document.setProcessingStatus(Document.ProcessingStatus.EMBEDDINGS_GENERATED);</span>
<span class="fc" id="L131">      document = documentRepository.save(document);</span>

      // Step 4: Generate summary (optional - can be implemented later)
<span class="fc" id="L134">      System.out.println(&quot;Step 4: Generating summary for document: &quot; + document.getId());</span>
<span class="fc" id="L135">      String summary = generateSummary(extractedText);</span>

<span class="fc" id="L137">      document.setSummary(summary);</span>
<span class="fc" id="L138">      document.setProcessingStatus(Document.ProcessingStatus.COMPLETED);</span>
<span class="fc" id="L139">      document = documentRepository.save(document);</span>

<span class="fc" id="L141">      System.out.println(&quot;Successfully processed document: &quot; + document.getFilename() + &quot; with &quot;</span>
<span class="fc" id="L142">          + chunks.size() + &quot; chunks&quot;);</span>
<span class="fc" id="L143">      return document;</span>

<span class="fc" id="L145">    } catch (Exception e) {</span>
<span class="fc" id="L146">      System.err.println(&quot;Error processing document &quot; + document.getId() + &quot;: &quot; + e.getMessage());</span>
<span class="fc" id="L147">      e.printStackTrace();</span>
<span class="fc" id="L148">      document.setProcessingStatus(Document.ProcessingStatus.FAILED);</span>
<span class="fc" id="L149">      documentRepository.save(document);</span>
<span class="fc" id="L150">      throw new RuntimeException(&quot;Document processing failed&quot;, e);</span>
    }
  }

  /**
   * Retrieves a document by its unique ID.
   */
  public Optional&lt;Document&gt; getDocumentById(Long id) {
<span class="fc" id="L158">    return documentRepository.findById(id);</span>
  }

  /**
   * Retrieves all stored documents.
   *
   * @return a list of all {@link Document} entities.
   */
  public List&lt;Document&gt; getAllDocuments() {
<span class="fc" id="L167">    return documentRepository.findAll();</span>
  }

  /**
   * Retrieves all documents matching a given filename.
   *
   * @return a list of all matching {@link Document} entities.
   */
  public List&lt;Document&gt; getDocumentsByFilename(String filename) {
<span class="fc" id="L176">    return documentRepository.findByFilenameContaining(filename);</span>
  }

  /**
   * Retrieves all documents that match a specific processing status.
   *
   * @param status the {@link Document.ProcessingStatus} filter.
   * @return a list of documents with the specified status.
   */
  public List&lt;Document&gt; getDocumentsByStatus(Document.ProcessingStatus status) {
<span class="fc" id="L186">    return documentRepository.findByProcessingStatus(status);</span>
  }

  /**
   * Deletes a document and all associated data such as chunks and embeddings.
   * &lt;p&gt;
   * This method properly handles cascading deletes by:
   * 1. Finding and deleting all document relationships associated with the
   * document's chunks
   * 2. Finding and deleting all document chunks associated with the document
   * 3. Finally deleting the document itself
   * &lt;/p&gt;
   *
   * @param id the ID of the document to delete.
   */
  @Transactional
  public void deleteDocument(Long id) {
<span class="fc" id="L203">    Optional&lt;Document&gt; documentOpt = documentRepository.findById(id);</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">    if (documentOpt.isEmpty()) {</span>
<span class="fc" id="L205">      System.out.println(&quot;Document not found: &quot; + id);</span>
<span class="fc" id="L206">      return;</span>
    }

<span class="fc" id="L209">    Document document = documentOpt.get();</span>

    // Step 1: Delete all relationships associated with this document's chunks using
    // native query
    // This avoids loading entities with embeddings which can cause converter issues
<span class="fc" id="L214">    int relationshipsDeleted = documentRelationshipRepository.deleteByDocumentIdNative(id);</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">    if (relationshipsDeleted &gt; 0) {</span>
<span class="fc" id="L216">      System.out.println(&quot;Deleted &quot; + relationshipsDeleted + &quot; relationships for document: &quot; + id);</span>
    }

    // Step 2: Delete all chunks associated with this document using native query
    // This avoids loading entities with embeddings which can cause converter issues
<span class="fc" id="L221">    int chunksDeleted = documentChunkRepository.deleteByDocumentIdNative(id);</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">    if (chunksDeleted &gt; 0) {</span>
<span class="fc" id="L223">      System.out.println(&quot;Deleted &quot; + chunksDeleted + &quot; chunks for document: &quot; + id);</span>
    }

    // Step 3: Delete the document itself
<span class="fc" id="L227">    documentRepository.delete(document);</span>
<span class="fc" id="L228">    System.out.println(&quot;Deleted document: &quot; + id);</span>
<span class="fc" id="L229">  }</span>

  /**
   * Retrieves all {@link DocumentChunk} instances belonging to a given document.
   *
   * @param documentId the ID of the document.
   * @return a list of chunks for the specified document.
   * @throws IllegalArgumentException if the document does not exist.
   */
  public List&lt;DocumentChunk&gt; getDocumentChunks(Long documentId) {
<span class="fc" id="L239">    return chunkingService.getChunksForDocument(documentId);</span>
  }

  /**
   * Retrieves statistical information about the chunking of a document,
   * including the number of chunks, average chunk length, and overlap ratio.
   *
   * @param documentId the ID of the document to analyze.
   * @return a {@link DocumentChunkingService.ChunkStatistics} object containing
   *         metrics.
   * @throws IllegalArgumentException if the document is not found.
   */
  public DocumentChunkingService.ChunkStatistics getChunkStatistics(Long documentId) {
<span class="fc" id="L252">    Optional&lt;Document&gt; document = getDocumentById(documentId);</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">    if (document.isEmpty()) {</span>
<span class="fc" id="L254">      throw new IllegalArgumentException(&quot;Document not found: &quot; + documentId);</span>
    }
<span class="fc" id="L256">    return chunkingService.getChunkStatistics(document.get());</span>
  }

  /**
   * Generates embeddings for all chunks of a given document that currently
   * lack embeddings in the database.
   *
   * @param documentId the ID of the document to process.
   * @return the number of chunks for which embeddings were generated.
   */
  @Transactional
  public int generateEmbeddingsForDocument(Long documentId) {
<span class="fc" id="L268">    return embeddingService.generateEmbeddingsForDocument(documentId);</span>
  }

  /**
   * Finds chunks that are semantically similar to a given query text.
   *
   * @param queryText the query string to match against.
   * @param limit     the maximum number of similar chunks to return.
   * @return a list of the most similar {@link DocumentChunk} entities.
   */
  public List&lt;DocumentChunk&gt; findSimilarChunks(String queryText, int limit) {
<span class="fc" id="L279">    return embeddingService.findSimilarChunks(queryText, limit);</span>
  }

  /**
   * Generates a simple summary of the documentâ€™s text content (placeholder for
   * now).
   *
   * @param text the extracted text to summarize.
   * @return a short summary string, or a placeholder message if text is
   *         unavailable.
   */
  private String generateSummary(String text) {
<span class="pc bpc" id="L291" title="2 of 4 branches missed.">    if (text == null || text.trim().isEmpty()) {</span>
<span class="nc" id="L292">      return &quot;No summary available&quot;;</span>
    }

    // Simple truncation-based summary (first 200 characters)
<span class="fc" id="L296">    String cleanedText = text.replaceAll(&quot;\\s+&quot;, &quot; &quot;).trim();</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">    if (cleanedText.length() &lt;= 200) {</span>
<span class="fc" id="L298">      return cleanedText;</span>
    }

    // Try to break at sentence boundary
<span class="fc" id="L302">    String truncated = cleanedText.substring(0, 200);</span>
<span class="fc" id="L303">    int lastPeriod = truncated.lastIndexOf('.');</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">    if (lastPeriod &gt; 100) {</span>
<span class="fc" id="L305">      return truncated.substring(0, lastPeriod + 1);</span>
    }

<span class="fc" id="L308">    return truncated + &quot;...&quot;;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>