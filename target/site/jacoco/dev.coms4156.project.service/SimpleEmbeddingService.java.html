<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SimpleEmbeddingService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Knowledge Management Service</a> &gt; <a href="index.source.html" class="el_package">dev.coms4156.project.service</a> &gt; <span class="el_source">SimpleEmbeddingService.java</span></div><h1>SimpleEmbeddingService.java</h1><pre class="source lang-java linenums">package dev.coms4156.project.service;

import dev.coms4156.project.model.DocumentChunk;
import dev.coms4156.project.repository.DocumentChunkRepository;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.springframework.ai.embedding.EmbeddingModel;
import org.springframework.ai.embedding.EmbeddingRequest;
import org.springframework.ai.embedding.EmbeddingResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * Embedding service using Spring AI with Ollama for local embedding generation
 * Uses llama3.2 model for 4096-dimensional embeddings.
 */
@Service
public class SimpleEmbeddingService {

  private final DocumentChunkRepository documentChunkRepository;
  private final EmbeddingModel embeddingModel;

  @Autowired
  public SimpleEmbeddingService(DocumentChunkRepository documentChunkRepository,
<span class="fc" id="L28">                                EmbeddingModel embeddingModel) {</span>
<span class="fc" id="L29">    this.documentChunkRepository = documentChunkRepository;</span>
<span class="fc" id="L30">    this.embeddingModel = embeddingModel;</span>
<span class="fc" id="L31">  }</span>

  /**
   * Generates an embedding for a given {@link DocumentChunk} using the Ollama embedding model.
   *
   * @param chunk the {@link DocumentChunk} containing text content to embed.
   * @return the same {@link DocumentChunk} with its embedding field populated.
   * @throws IllegalArgumentException if the chunk or its text content is null or empty.
   * @throws RuntimeException         if embedding generation or database insertion fails.
   */
  @Transactional
  public DocumentChunk generateEmbedding(DocumentChunk chunk) {
<span class="pc bpc" id="L43" title="1 of 4 branches missed.">    if (chunk == null || chunk.getTextContent() == null</span>
<span class="fc bfc" id="L44" title="All 2 branches covered.">        || chunk.getTextContent().trim().isEmpty()) {</span>
<span class="fc" id="L45">      throw new IllegalArgumentException(&quot;Chunk or text content cannot be null or empty&quot;);</span>
    }

    try {
<span class="fc" id="L49">      String text = chunk.getTextContent();</span>
<span class="fc" id="L50">      float[] embeddingArray = generateOllamaEmbeddingArray(text);</span>

      // Convert to string format for native SQL
<span class="fc" id="L53">      String embeddingString = convertFloatArrayToVectorString(embeddingArray);</span>

      // Use native SQL to insert with proper vector casting
<span class="fc" id="L56">      documentChunkRepository.insertChunkWithEmbedding(</span>
<span class="fc" id="L57">          chunk.getChunkIndex(),</span>
<span class="fc" id="L58">          chunk.getChunkSize(),</span>
<span class="fc" id="L59">          chunk.getDocument().getId(),</span>
          embeddingString,
<span class="fc" id="L61">          chunk.getEndPosition(),</span>
<span class="fc" id="L62">          chunk.getStartPosition(),</span>
<span class="fc" id="L63">          chunk.getTextContent());</span>

      // Set embedding on chunk for return value
<span class="fc" id="L66">      chunk.setEmbedding(embeddingArray);</span>
<span class="fc" id="L67">      return chunk;</span>
<span class="fc" id="L68">    } catch (Exception e) {</span>
<span class="fc" id="L69">      throw new RuntimeException(&quot;Failed to generate embedding for chunk: &quot; + e.getMessage(), e);</span>
    }
  }

  /**
   * Generates embeddings for a list of {@link DocumentChunk} objects.
   *
   * @param chunks the list of {@link DocumentChunk} objects to process.
   * @return a list of successfully processed chunks with embeddings generated.
   */
  @Transactional
  public List&lt;DocumentChunk&gt; generateEmbeddings(List&lt;DocumentChunk&gt; chunks) {
<span class="fc bfc" id="L81" title="All 4 branches covered.">    if (chunks == null || chunks.isEmpty()) {</span>
<span class="fc" id="L82">      return new ArrayList&lt;&gt;();</span>
    }

<span class="fc" id="L85">    List&lt;DocumentChunk&gt; processedChunks = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L87" title="All 2 branches covered.">    for (DocumentChunk chunk : chunks) {</span>
<span class="pc bpc" id="L88" title="2 of 4 branches missed.">      if (chunk.getTextContent() != null &amp;&amp; !chunk.getTextContent().trim().isEmpty()) {</span>
        try {
<span class="fc" id="L90">          float[] embeddingArray = generateOllamaEmbeddingArray(chunk.getTextContent());</span>
<span class="fc" id="L91">          String embeddingString = convertFloatArrayToVectorString(embeddingArray);</span>

          // Use native SQL to insert with proper vector casting
<span class="fc" id="L94">          documentChunkRepository.insertChunkWithEmbedding(</span>
<span class="fc" id="L95">              chunk.getChunkIndex(),</span>
<span class="fc" id="L96">              chunk.getChunkSize(),</span>
<span class="fc" id="L97">              chunk.getDocument().getId(),</span>
              embeddingString,
<span class="fc" id="L99">              chunk.getEndPosition(),</span>
<span class="fc" id="L100">              chunk.getStartPosition(),</span>
<span class="fc" id="L101">              chunk.getTextContent());</span>

          // Set embedding on chunk for return value
<span class="fc" id="L104">          chunk.setEmbedding(embeddingArray);</span>
<span class="fc" id="L105">          processedChunks.add(chunk);</span>
<span class="nc" id="L106">        } catch (Exception e) {</span>
<span class="nc" id="L107">          System.err</span>
<span class="nc" id="L108">              .println(&quot;Failed to generate embedding for chunk &quot; + chunk.getId() + &quot;: &quot;</span>
<span class="nc" id="L109">                  + e.getMessage());</span>
          // Continue processing other chunks
<span class="fc" id="L111">        }</span>
      }
<span class="fc" id="L113">    }</span>

<span class="fc" id="L115">    return processedChunks;</span>
  }

  /**
   * Generates a float array embedding for the given text using the Ollama embedding model.
   *
   * @param text the text content to embed.
   * @return a float array representing the embedding vector.
   * @throws RuntimeException if the embedding generation fails or returns no result.
   */
  private float[] generateOllamaEmbeddingArray(String text) {
    try {
<span class="fc" id="L127">      System.out.println(</span>
<span class="fc" id="L128">          &quot;Generating embedding for text: &quot; + text.substring(0, Math.min(100, text.length()))</span>
              + &quot;...&quot;);
<span class="fc" id="L130">      EmbeddingRequest request = new EmbeddingRequest(List.of(text), null);</span>
<span class="fc" id="L131">      EmbeddingResponse response = embeddingModel.call(request);</span>

<span class="pc bpc" id="L133" title="2 of 4 branches missed.">      if (response.getResults() != null &amp;&amp; !response.getResults().isEmpty()) {</span>
<span class="fc" id="L134">        float[] embedding = response.getResults().get(0).getOutput();</span>
<span class="fc" id="L135">        System.out.println(</span>
            &quot;Successfully generated embedding with &quot; + embedding.length + &quot; dimensions&quot;);
<span class="fc" id="L137">        return embedding;</span>
      } else {
<span class="nc" id="L139">        throw new RuntimeException(&quot;No embedding result returned from Ollama&quot;);</span>
      }
<span class="fc" id="L141">    } catch (Exception e) {</span>
<span class="fc" id="L142">      System.err.println(&quot;Failed to generate Ollama embedding: &quot; + e.getMessage());</span>
<span class="fc" id="L143">      throw new RuntimeException(&quot;Failed to generate Ollama embedding: &quot; + e.getMessage(), e);</span>
    }
  }

  /**
   * Converts a float array into a PostgreSQL-compatible vector string format.
   *
   * @param vector the float array to convert.
   * @return the vector as a formatted string.
   * @throws IllegalArgumentException if the input array is null or empty.
   */
  private String convertFloatArrayToVectorString(float[] vector) {
<span class="pc bpc" id="L155" title="2 of 4 branches missed.">    if (vector == null || vector.length == 0) {</span>
<span class="nc" id="L156">      throw new IllegalArgumentException(&quot;Vector cannot be null or empty&quot;);</span>
    }

<span class="fc" id="L159">    StringBuilder vectorString = new StringBuilder(&quot;[&quot;);</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">    for (int i = 0; i &lt; vector.length; i++) {</span>
<span class="fc" id="L161">      vectorString.append(vector[i]);</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">      if (i &lt; vector.length - 1) {</span>
<span class="fc" id="L163">        vectorString.append(&quot;,&quot;);</span>
      }
    }
<span class="fc" id="L166">    vectorString.append(&quot;]&quot;);</span>
<span class="fc" id="L167">    return vectorString.toString();</span>
  }


  /**
   * Finds document chunks that are semantically similar to a given query text.
   *
   * @param queryText the input text used to find similar chunks.
   * @param limit     the maximum number of similar chunks to return.
   * @return a list of similar {@link DocumentChunk} results, or an empty list if none found.
   */
  public List&lt;DocumentChunk&gt; findSimilarChunks(String queryText, int limit) {
<span class="fc bfc" id="L179" title="All 4 branches covered.">    if (queryText == null || queryText.trim().isEmpty()) {</span>
<span class="fc" id="L180">      return new ArrayList&lt;&gt;();</span>
    }

    try {
      // Generate embedding for the query text
<span class="fc" id="L185">      float[] queryEmbeddingArray = generateOllamaEmbeddingArray(queryText);</span>
<span class="fc" id="L186">      String queryEmbedding = convertFloatArrayToVectorString(queryEmbeddingArray);</span>

<span class="fc" id="L188">      System.out.println(&quot;Search query embedding dimensions: &quot; + queryEmbeddingArray.length);</span>
<span class="fc" id="L189">      System.out.println(&quot;Search query embedding preview: &quot;</span>
<span class="fc" id="L190">          + queryEmbedding.substring(0, Math.min(50, queryEmbedding.length())) + &quot;...&quot;);</span>

      // Use PostgreSQL vector similarity search
<span class="fc" id="L193">      List&lt;DocumentChunk&gt; results =</span>
<span class="fc" id="L194">          documentChunkRepository.findSimilarChunks(queryEmbedding, limit);</span>
<span class="fc" id="L195">      System.out.println(&quot;Found &quot; + results.size() + &quot; similar chunks&quot;);</span>
<span class="fc" id="L196">      return results;</span>
<span class="fc" id="L197">    } catch (Exception e) {</span>
<span class="fc" id="L198">      System.err.println(&quot;Failed to find similar chunks: &quot; + e.getMessage());</span>
<span class="fc" id="L199">      return new ArrayList&lt;&gt;();</span>
    }
  }


  /**
   * Calculates the cosine similarity between two embedding vectors.
   *
   * @param embedding1 the first embedding vector.
   * @param embedding2 the second embedding vector.
   * @return a double value representing similarity in the range [-1, 1].
   */
  public double calculateSimilarity(float[] embedding1, float[] embedding2) {
<span class="pc bpc" id="L212" title="2 of 8 branches missed.">    if (embedding1 == null || embedding2 == null || embedding1.length == 0</span>
        || embedding2.length == 0) {
<span class="fc" id="L214">      return 0.0;</span>
    }

    try {
<span class="fc" id="L218">      return calculateCosineSimilarity(embedding1, embedding2);</span>
<span class="fc" id="L219">    } catch (Exception e) {</span>
<span class="fc" id="L220">      System.err.println(&quot;Failed to calculate similarity: &quot; + e.getMessage());</span>
<span class="fc" id="L221">      return 0.0;</span>
    }
  }


  /**
   * Computes cosine similarity between two equal-length float vectors.
   *
   * @param vector1 the first vector.
   * @param vector2 the second vector.
   * @return cosine similarity as a double.
   * @throws IllegalArgumentException if the two vectors have different lengths.
   */
  private double calculateCosineSimilarity(float[] vector1, float[] vector2) {
<span class="fc bfc" id="L235" title="All 2 branches covered.">    if (vector1.length != vector2.length) {</span>
<span class="fc" id="L236">      throw new IllegalArgumentException(&quot;Vectors must have the same dimension&quot;);</span>
    }

<span class="fc" id="L239">    double dotProduct = 0.0;</span>
<span class="fc" id="L240">    double norm1 = 0.0;</span>
<span class="fc" id="L241">    double norm2 = 0.0;</span>

<span class="fc bfc" id="L243" title="All 2 branches covered.">    for (int i = 0; i &lt; vector1.length; i++) {</span>
<span class="fc" id="L244">      double v1 = vector1[i];</span>
<span class="fc" id="L245">      double v2 = vector2[i];</span>
<span class="fc" id="L246">      dotProduct += v1 * v2;</span>
<span class="fc" id="L247">      norm1 += v1 * v1;</span>
<span class="fc" id="L248">      norm2 += v2 * v2;</span>
    }

<span class="pc bpc" id="L251" title="1 of 4 branches missed.">    if (norm1 == 0.0 || norm2 == 0.0) {</span>
<span class="fc" id="L252">      return 0.0;</span>
    }

<span class="fc" id="L255">    return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));</span>
  }

  /**
   * Retrieves statistics about the stored embeddings.
   *
   * @return a map containing embedding statistics and model metadata.
   */
  public Map&lt;String, Object&gt; getEmbeddingStatistics() {
<span class="fc" id="L264">    Map&lt;String, Object&gt; stats = new HashMap&lt;&gt;();</span>

    try {
<span class="fc" id="L267">      long totalChunks = documentChunkRepository.count();</span>
<span class="fc" id="L268">      long chunksWithEmbeddings = documentChunkRepository.countByEmbeddingIsNotNull();</span>

<span class="fc" id="L270">      stats.put(&quot;totalChunks&quot;, totalChunks);</span>
<span class="fc" id="L271">      stats.put(&quot;chunksWithEmbeddings&quot;, chunksWithEmbeddings);</span>
<span class="fc" id="L272">      stats.put(&quot;embeddingCoverage&quot;,</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">          totalChunks &gt; 0 ? (double) chunksWithEmbeddings / totalChunks : 0.0);</span>
<span class="fc" id="L274">      stats.put(&quot;model&quot;, &quot;llama3.2&quot;);</span>
<span class="fc" id="L275">      stats.put(&quot;dimensions&quot;, 4096);</span>
<span class="fc" id="L276">      stats.put(&quot;provider&quot;, &quot;Ollama&quot;);</span>

<span class="fc" id="L278">    } catch (Exception e) {</span>
<span class="fc" id="L279">      stats.put(&quot;error&quot;, &quot;Failed to get embedding statistics: &quot; + e.getMessage());</span>
<span class="fc" id="L280">    }</span>

<span class="fc" id="L282">    return stats;</span>
  }

  /**
   * Generates embeddings for all chunks of a specific document that do not yet have embeddings.
   *
   * @param documentId the ID of the document whose chunks should be embedded.
   * @return the number of chunks successfully processed.
   */
  @Transactional
  public int generateEmbeddingsForDocument(Long documentId) {
<span class="fc" id="L293">    List&lt;DocumentChunk&gt; chunks =</span>
<span class="fc" id="L294">        documentChunkRepository.findByDocumentIdAndEmbeddingIsNull(documentId);</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">    if (chunks.isEmpty()) {</span>
<span class="fc" id="L296">      return 0;</span>
    }

<span class="fc" id="L299">    List&lt;DocumentChunk&gt; processedChunks = generateEmbeddings(chunks);</span>
<span class="fc" id="L300">    return processedChunks.size();</span>
  }


  /**
   * Tests the connectivity and functionality of the Ollama embedding model.
   *
   * @return a map containing connection status, message, and embedding metadata.
   */
  public Map&lt;String, Object&gt; testConnection() {
<span class="fc" id="L310">    Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();</span>

    try {
<span class="fc" id="L313">      String testText = &quot;This is a test for Ollama embedding generation.&quot;;</span>
<span class="fc" id="L314">      float[] embeddingArray = generateOllamaEmbeddingArray(testText);</span>

<span class="fc" id="L316">      result.put(&quot;status&quot;, &quot;success&quot;);</span>
<span class="fc" id="L317">      result.put(&quot;message&quot;, &quot;Ollama connection successful&quot;);</span>
<span class="fc" id="L318">      result.put(&quot;testText&quot;, testText);</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">      result.put(&quot;embeddingGenerated&quot;, embeddingArray.length &gt; 0);</span>
<span class="fc" id="L320">      result.put(&quot;embeddingDimensions&quot;, embeddingArray.length);</span>

<span class="nc" id="L322">    } catch (Exception e) {</span>
<span class="nc" id="L323">      result.put(&quot;status&quot;, &quot;error&quot;);</span>
<span class="nc" id="L324">      result.put(&quot;message&quot;, &quot;Ollama connection failed: &quot; + e.getMessage());</span>
<span class="fc" id="L325">    }</span>

<span class="fc" id="L327">    return result;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>